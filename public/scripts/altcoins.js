// altcoins.js

// coins list
export const coins = [
  {
    name: "Kitcoin KITTY",
    contract: "0x4d7c922D6C12CfbF5BC85F56c9ccB1F61f49bf61",
    icon: "./assets/kitty.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xdc1ff76d4737b2f54bbf42656fb998650b7a2b00%2C0xc3d569fa65b7ec8d4f1350d19b96f0330124c3f5%2C0x90828bff571be8b64f48067c65533d93cf017230%2C",
  },
  {
    name: "Reaper's Squad REAPER",
    contract: "0x73712A912AE5e39634046F4409Ef57eac34E96BA",
    icon: "./assets/reaper.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xa46e17e884b4f7c0db252fc055ef8d14b2271d7c%2C0x078150fdeedb5b8f16a4b2950f839eda393d2fc7%2C0x3fd9ead82392898e185c0619baf66dbc00b3196c%2C0xba12e9c4ea0f64ecef217905ccfa97421a74e54e%2C",
  },
  {
    name: "FORTUNE FAVOURS THE BRAVE FFTB",
    contract: "0xd677944Df705924AF369d2FCcf4A989f343DbCDf",
    icon: "./assets/fftb.jpg",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0x5aa62d8711ca4af5c3f809a3cbe8d7ed6a0bd9c2%2C0xab708f371cb3568531822936bba1ae87fa3c1d00%2C0x40e4a6bd76dd986ec310bdfdf230a4cd2f0086de%2C",
  },
  {
    name: "Turtle TURTLE",
    contract: "0x8C9E2bEf2962CE302ef578113eebEc62920B7e57",
    icon: "./assets/turtle.webp",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xea8f22344dd9269b030381f676432270a22a5837%2C0xf5d8f38541abdd4e5e9a50af11ebae9b7780f6fb",
  },
  {
    name: "CorgiAI CORGIAI",
    contract: "0xccccccccdbec186dc426f8b5628af94737df0e60",
    icon: "./assets/corgiai.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0x189291476338446c6e62c8a18ef22d3c80eb5f72%2C0x8f9baccf9a130a755520cbabb20543adb3006f14%2C0xd459cf47ee9df418388eb2a7a46f5e30d15757d7%2C0xd3ac6188048459253dab087de984e72e344a8233%2C0xd7c950dcefec084c66cf0fa9e3b545da2424fe1a",
  },
  {
    name: "crow with knife CAW",
    contract: "0xccccccccdbec186dc426f8b5628af94737df0e60",
    icon: "./assets/caw.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xc7a139c804a3bbdfe90d32c100dffeca1a2f735c%2C0xbd7662497dad446047d74d55f8244a5161b78eec%2C0xaef7fb05f05aa35d3a8bca11f16f0d3387f47191%2C0x6023768757d8749066597403510b3f69c39f03c5",
  },
  {
    name: "Croakey CROAK",
    contract: "0xed70e1b02a63fafd5ece7c0a2a1b12d4b424b4a8",
    icon: "./assets/croak.webp",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0x9cc7826047d03e3f1d7eadfcdc75bfdfcdfebc52%2C0xfa58287ee181307072e07bbbb5bb81a59926a143%2C0x42b01e2efd9b971c87728cef8d11e1e56a3c1bca%2C0x4e3ed2e098932fb48bb923991c8448e9952a64e7",
  },
  {
    name: "Moonflow MOON",
    contract: "0x46e2b5423f6ff46a8a35861ec9daff26af77ab9a",
    icon: "./assets/moon.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0x9e5a2f511cfc1eb4a6be528437b9f2ddcaef9975%2C0x478b6c0f22927d97ef686632ea2d34a47dd22eed%2C0x886fd55d15bbfc444c23ac5f6dbebeeca4832971%2C0xedb5b48958b09f670866f51c6680b6b07af955dc",
  },
  {
    name: "Mistery MERY",
    contract: "0x3b41b27e74dd366ce27cb389dc7877d4e1516d4d",
    icon: "./assets/mistery.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xa51231984ff01f4933a9fa24e8fd143f18ae6772%2C0x06465ee5c246ee82b1eed2b2bd9a3a5457013c5a%2C0x54efb7841bc8f454799f78c33e6001fea296d71f%2C0xe1e46f2f4fb12b35c466b468650b2b7f61bbcbfc%2C0x779ac56c17c353cf6c7681bea60de189b0429575",
  },
  {
    name: "VVS Finance",
    contract: "0x2d03bece6747adc00e1a131bba1469c15fd11e03",
    icon: "./assets/vvs.jpg",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xbf62c67ea509e86f07c8c69d0286c0636c50270b",
  },
  {
    name: "Mad Meerkat Finance",
    contract: "0x1a9f22b4c385f78650e7874d64e442839dc32327",
    icon: "./assets/mmf.jpg",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xba452a1c0875d33a440259b1ea4dca8f5d86d9ae%2C0x722f19bd9a1e5ba97b3020c6028c279d27e4293c%2C0x5801d37e04ab1f266c35a277e06c9d3afa1c9ca2",
  },
  {
    name: "Crodex Token CRX",
    contract: "0x4d03f8b5d8fbe17d84e1b709b0d5e17eb9a6b7b8",
    icon: "./assets/crx.png",
    apiUrl:
      "https://api.geckoterminal.com/api/v2/networks/cro/pools/multi/0xd141aed3fa86f411808d5d74bebbc038e94f300d%2C0x77c30a3940a7178683afc75e1e97dd51ad80bdd0%2C0xa6e9f20a93e0b50f074bc2fc693e8add3812f8c4%2C0x89e1135b2c82feb19f5ecb78e35c309a6aef7b01",
  },
];

const BROWSER_CACHE_DURATION = 10 * 60 * 1000; // 10 minutes

// Function to retrieve and merge data with browser caching
export async function fetchCoinData(coin) {
// Use the apiUrl as key for the cache
  const storageKey = "coinData_" + encodeURIComponent(coin.apiUrl);
  const cacheTimeKey = storageKey + "_time";
  const now = Date.now();

  // try to get the data from the cache
  const cachedData = localStorage.getItem(storageKey);
  const cachedTime = localStorage.getItem(cacheTimeKey);

  if (cachedData && cachedTime && now - parseInt(cachedTime, 10) < BROWSER_CACHE_DURATION) {
    return JSON.parse(cachedData);
  }

  // if not in cache, fetch the data
  try {
    const response = await fetch(coin.apiUrl);
    if (!response.ok)
      throw new Error(`HTTP error! Status: ${response.status}`);

    const data = await response.json();
    const pools = data.data;

    let combinedData = {
      totalVolumeUsd: 0,
      totalBasePriceUsd: 0,
      priceChange1h: 0,
      priceChange24h: 0,
      marketCap: null,
    };

    // unique set to avoid duplicate pools
    const processedPools = new Set();

    pools.forEach((pool) => {
      const poolId = pool.id;

      if (processedPools.has(poolId)) {
        console.log(`Skipping duplicate pool: ${poolId}`);
        return;
      }

      processedPools.add(poolId);

      const attributes = pool.attributes;
      const volume = parseFloat(attributes.volume_usd?.h24) || 0;
      const basePrice = parseFloat(attributes.base_token_price_usd) || 0;

      combinedData.totalVolumeUsd += volume;

      // control if market cap is already set
      if (!combinedData.marketCap) {
        if (attributes.market_cap_usd) {
          combinedData.marketCap = parseFloat(attributes.market_cap_usd);
        } else if (attributes.fdv_usd) {
          combinedData.marketCap = parseFloat(attributes.fdv_usd);
        } else if (attributes.reserve_in_usd && attributes.base_token_price_usd) {
          const reserveUsd = parseFloat(attributes.reserve_in_usd);
          const baseTokenPrice = parseFloat(attributes.base_token_price_usd);
          combinedData.marketCap = reserveUsd / baseTokenPrice;
          console.log(`Calculated Market Cap from Reserve and Base Price: ${combinedData.marketCap}`);
        } else {
          console.log("Market Cap could not be determined for this pool.");
        }
      }

      combinedData.totalBasePriceUsd += volume > 0 ? basePrice * volume : 0;
      combinedData.priceChange1h += parseFloat(attributes.price_change_percentage?.h1 || 0) * volume;
      combinedData.priceChange24h += parseFloat(attributes.price_change_percentage?.h24 || 0) * volume;
    });

    const result = {
      name: coin.name,
      contract: coin.contract,
      icon: coin.icon,
      price: combinedData.totalBasePriceUsd
        ? (combinedData.totalBasePriceUsd / combinedData.totalVolumeUsd).toFixed(10)
        : "N/A",
      priceChange1h:
        combinedData.totalVolumeUsd > 0
          ? (combinedData.priceChange1h / combinedData.totalVolumeUsd).toFixed(2)
          : "0.00",
      priceChange24h:
        combinedData.totalVolumeUsd > 0
          ? (combinedData.priceChange24h / combinedData.totalVolumeUsd).toFixed(2)
          : "0.00",
      marketCap: combinedData.marketCap
        ? combinedData.marketCap.toLocaleString("en-US", {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          })
        : "N/A",
      volume24h: combinedData.totalVolumeUsd
        ? combinedData.totalVolumeUsd.toLocaleString()
        : "N/A",
    };

    // save the data to the cache
    localStorage.setItem(storageKey, JSON.stringify(result));
    localStorage.setItem(cacheTimeKey, now.toString());

    return result;
  } catch (error) {
    console.error(`Error fetching data for ${coin.name}:`, error);
    return null;
  }
}

// table rendering function
export async function populateAltcoinTable(searchQuery = "") {
  const tableBody = document.querySelector("#altcoin-table");
  const tableHeaders = document.querySelectorAll(".main-crypto-table th");

  if (!tableBody) {
    console.error("Altcoin table element not found.");
    return;
  }

  let currentSortKey = "marketCap"; // default sort key
  let sortAscending = false;

  const allCoinData = await Promise.all(coins.map(fetchCoinData));
  let validCoinData = allCoinData.filter((data) => data !== null);

  // filter by search query
  validCoinData = validCoinData.filter(
    (coin) =>
      coin &&
      (coin.name.toLowerCase().includes(searchQuery.toLowerCase().trim()) ||
        coin.contract.toLowerCase().includes(searchQuery.toLowerCase().trim()))
  );

  function renderTable() {
    const rowsHtml = validCoinData
      .map((coin, index) => {
        function formatChange(change) {
          const arrow = change >= 0 ? "↑" : "↓";
          const colorClass = change >= 0 ? "positive-change" : "negative-change";
          return `<span class="${colorClass}">${arrow} ${Math.abs(change)}%</span>`;
        }

        return `
          <tr>
            <td>${index + 1}</td>
            <td>
              <a href="coin.html?id=${coin.name}" class="coin-link">
                <img src="${coin.icon}" alt="${coin.name} Logo" class="crypto-logo">
                ${coin.name}
              </a>
            </td>
            <td>$${coin.price}</td>
            <td>${formatChange(coin.priceChange1h)}</td>
            <td>${formatChange(coin.priceChange24h)}</td>
            <td>$${coin.marketCap || "N/A"}</td>
            <td>$${coin.volume24h || "N/A"}</td>
          </tr>
        `;
      })
      .join("");

    tableBody.innerHTML =
      rowsHtml || "<tr><td colspan='7'>No matching coins found.</td></tr>";
  }

  function sortTable(key) {
    validCoinData.sort((a, b) => {
      const valueA = parseFloat(a[key]?.replace(/[.,]/g, "")) || 0;
      const valueB = parseFloat(b[key]?.replace(/[.,]/g, "")) || 0;
      return sortAscending ? valueA - valueB : valueB - valueA;
    });
    renderTable();
  }

  tableHeaders.forEach((header, index) => {
    header.addEventListener("click", () => {
      const sortKeys = [
        null,
        "name",
        "price",
        "priceChange1h",
        "priceChange24h",
        "marketCap",
        "volume24h",
      ];
      const key = sortKeys[index];
      if (key) {
        sortAscending = currentSortKey === key ? !sortAscending : false;
        currentSortKey = key;
        sortTable(key);
      }
    });
  });

  sortTable(currentSortKey);
}

// search bar setup
export function setupSearch() {
  const searchInput = document.querySelector("#search-bar");
  searchInput.addEventListener("input", (event) => {
    const searchQuery = event.target.value;
    populateAltcoinTable(searchQuery);
  });
}

// load the table and search bar when the page is ready
document.addEventListener("DOMContentLoaded", () => {
  populateAltcoinTable();
  setupSearch();
});
